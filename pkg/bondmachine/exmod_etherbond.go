package bondmachine

import (
	"github.com/BondMachineHQ/BondMachine/pkg/bmcluster"
	"github.com/BondMachineHQ/BondMachine/pkg/etherbond"

	//"fmt"
	"strconv"
)

type Etherbond_extra struct {
	Config  *etherbond.Config
	Cluster *bmcluster.Cluster
	Macs    *etherbond.Macs
	PeerID  uint32
	Maps    *IOmap
	Flavor  string
	Mac     string
}

func (sl *Etherbond_extra) Get_Name() string {
	return "etherbond"
}

func (sl *Etherbond_extra) Get_Params() *ExtraParams {
	result := new(ExtraParams)
	result.Params = make(map[string]string)
	result.Params["peer_id"] = strconv.Itoa(int(sl.PeerID))
	result.Params["cluster_id"] = strconv.Itoa(int(sl.Cluster.ClusterId))
	result.Params["mac"] = sl.Mac

	var mypeer bmcluster.Peer

	for _, peer := range sl.Cluster.Peers {
		if peer.PeerId == sl.PeerID {
			mypeer = peer
		}

		if sl.Macs != nil {
			peerstr := strconv.Itoa(int(peer.PeerId))
			if mac, ok := sl.Macs.Assoc["peer_"+peerstr]; ok {
				if mac == "auto" {
					result.Params["peer_"+peerstr+"_mac"] = "auto"
				} else if mac == "adv" {
					result.Params["peer_"+peerstr+"_mac"] = "auto"
				} else {
					result.Params["peer_"+peerstr+"_mac"] = mac
				}
			} else {
				result.Params["peer_"+peerstr+"_mac"] = "auto"
			}
		}

	}

	result.Params["input_ids"] = ""
	result.Params["inputs"] = ""

	for _, inp := range mypeer.Inputs {
		for iname, ival := range sl.Maps.Assoc {
			if iname[0] == 'i' && ival == strconv.Itoa(int(inp)) {
				result.Params["input_ids"] += "," + ival
				result.Params["inputs"] += "," + iname
			}
		}
	}

	if result.Params["input_ids"] != "" {
		result.Params["input_ids"] = result.Params["input_ids"][1:len(result.Params["input_ids"])]
		result.Params["inputs"] = result.Params["inputs"][1:len(result.Params["inputs"])]
	}

	result.Params["output_ids"] = ""
	result.Params["outputs"] = ""
	// Comma separated and - separated list of peer ids
	result.Params["destinations"] = ""

	for _, outp := range mypeer.Outputs {
		for oname, oval := range sl.Maps.Assoc {
			if oname[0] == 'o' && oval == strconv.Itoa(int(outp)) {
				result.Params["output_ids"] += "," + oval
				result.Params["outputs"] += "," + oname

				resdest := ""
				for _, ipeer := range sl.Cluster.Peers {
					for _, iin := range ipeer.Inputs {
						//fmt.Println(ipeer.PeerId, iin, oval, strconv.Itoa(int(iin)))
						if strconv.Itoa(int(iin)) == oval {
							resdest += "-" + strconv.Itoa(int(ipeer.PeerId))
						}
					}
				}
				//fmt.Println("resdest", resdest)
				if resdest != "" {
					result.Params["destinations"] += "," + resdest[1:len(resdest)]
				}

			}
		}
	}

	if result.Params["output_ids"] != "" {
		result.Params["output_ids"] = result.Params["output_ids"][1:len(result.Params["output_ids"])]
		result.Params["outputs"] = result.Params["outputs"][1:len(result.Params["outputs"])]
		result.Params["destinations"] = result.Params["destinations"][1:len(result.Params["destinations"])]
	}

	return result
}

func (sl *Etherbond_extra) Import(inp string) error {
	return nil
}

func (sl *Etherbond_extra) Export() string {
	return ""
}

func (sl *Etherbond_extra) Check(bmach *Bondmachine) error {
	return nil
}

func (sl *Etherbond_extra) Verilog_headers() string {
	result := "\n"
	result += "  parameter [7:0] MYMAC_1 = 8'h" + sl.Mac[0:2] + ";\n"
	result += "  parameter [7:0] MYMAC_2 = 8'h" + sl.Mac[2:4] + ";\n"
	result += "  parameter [7:0] MYMAC_3 = 8'h" + sl.Mac[4:6] + ";\n"
	result += "  parameter [7:0] MYMAC_4 = 8'h" + sl.Mac[6:8] + ";\n"
	result += "  parameter [7:0] MYMAC_5 = 8'h" + sl.Mac[8:10] + ";\n"
	result += "  parameter [7:0] MYMAC_6 = 8'h" + sl.Mac[10:12] + ";\n"

	result += "\n"

	result += "  //Definition of the address for the SPI register\n"
	result += "  parameter [4:0] A_ERDPTL   = 5'h00; parameter [4:0] A_EHT0    = 5'h00; parameter [4:0] A_MACON1    = 5'h00; parameter [4:0] A_MAADR5   = 5'h00; \n"
	result += "  parameter [4:0] A_ERDPTH   = 5'h01; parameter [4:0] A_EHT1    = 5'h01;                                      parameter [4:0] A_MAADR6   = 5'h01; \n"
	result += "  parameter [4:0] A_EWRPTL   = 5'h02; parameter [4:0] A_EHT2    = 5'h02; parameter [4:0] A_MACON3    = 5'h02; parameter [4:0] A_MAADR3   = 5'h02; \n"
	result += "  parameter [4:0] A_EWRPTH   = 5'h03; parameter [4:0] A_EHT3    = 5'h03; parameter [4:0] A_MACON4    = 5'h03; parameter [4:0] A_MAADR4   = 5'h03; \n"
	result += "  parameter [4:0] A_ETXSTL   = 5'h04; parameter [4:0] A_EHT4    = 5'h04; parameter [4:0] A_MABBIPG   = 5'h04; parameter [4:0] A_MAADR1   = 5'h04; \n"
	result += "  parameter [4:0] A_ETXSTH   = 5'h05; parameter [4:0] A_EHT5    = 5'h05;		 			 parameter [4:0] A_MAADR2   = 5'h05; \n"
	result += "  parameter [4:0] A_ETXNDL   = 5'h06; parameter [4:0] A_EHT6    = 5'h06; parameter [4:0] A_MAIPGL    = 5'h06; parameter [4:0] A_EBSTSD   = 5'h06; \n"
	result += "  parameter [4:0] A_ETXNDH   = 5'h07; parameter [4:0] A_EHT7    = 5'h07; parameter [4:0] A_MAIPGH    = 5'h07; parameter [4:0] A_EBSTCON  = 5'h07; \n"
	result += "  parameter [4:0] A_ERXSTL   = 5'h08; parameter [4:0] A_EPMM0   = 5'h08; parameter [4:0] A_MACLCON1  = 5'h08; parameter [4:0] A_EBSTCSL  = 5'h08; \n"
	result += "  parameter [4:0] A_ERXSTH   = 5'h09; parameter [4:0] A_EPMM1   = 5'h09; parameter [4:0] A_MACLCON2  = 5'h09; parameter [4:0] A_EBSTCSH  = 5'h09; \n"
	result += "  parameter [4:0] A_ERXNDL   = 5'h0A; parameter [4:0] A_EPMM2   = 5'h0A; parameter [4:0] A_MAMXFLL   = 5'h0A; parameter [4:0] A_MISTAT   = 5'h0A; \n"
	result += "  parameter [4:0] A_ERXNDH   = 5'h0B; parameter [4:0] A_EPMM3   = 5'h0B; parameter [4:0] A_MAMXFLH   = 5'h0B; \n"
	result += "  parameter [4:0] A_ERXRDPTL = 5'h0C; parameter [4:0] A_EPMM4   = 5'h0C; \n"
	result += "  parameter [4:0] A_ERXRDPTH = 5'h0D; parameter [4:0] A_EPMM5   = 5'h0D; \n"
	result += "  parameter [4:0] A_ERXWRPTL = 5'h0E; parameter [4:0] A_EPMM6   = 5'h0E; \n"
	result += "  parameter [4:0] A_ERXWRPTH = 5'h0F; parameter [4:0] A_EPMM7   = 5'h0F; \n"
	result += "  parameter [4:0] A_EDMASTL  = 5'h10; parameter [4:0] A_EPMCSL  = 5'h10; \n"
	result += "  parameter [4:0] A_EDMASTH  = 5'h11; parameter [4:0] A_EPMCSH  = 5'h11; \n"
	result += "  parameter [4:0] A_EDMANDL  = 5'h12; parameter [4:0] A_MICMD     = 5'h12;  parameter [4:0] A_EREVID  = 5'h12;    \n"
	result += "  parameter [4:0] A_EDMANDH  = 5'h13; \n"
	result += "  parameter [4:0] A_EDMADSTL = 5'h14; parameter [4:0] A_EPMOL   = 5'h14; parameter [4:0] A_MIREGADR  = 5'h14;\n"
	result += "  parameter [4:0] A_EDMADSTH = 5'h15; parameter [4:0] A_EPMOH   = 5'h15; parameter [4:0] A_ECOCON  = 5'h15;\n"
	result += "  parameter [4:0] A_EDMACSL  = 5'h16; parameter [4:0] A_MIWRL   = 5'h16; \n"
	result += "  parameter [4:0] A_EDMACSH  = 5'h17; parameter [4:0] A_MIWRH   = 5'h17; parameter [4:0] A_EFLOCON = 5'h17;\n"
	result += "  parameter [4:0] A_ERXFCON  = 5'h18; parameter [4:0] A_MIRDL    = 5'h18;  parameter [4:0] A_EPAUSL  = 5'h18; \n"
	result += "  parameter [4:0] A_EPKTCNT  = 5'h19; parameter [4:0] A_MIRDH    = 5'h19;  parameter [4:0] A_EPAUSH  = 5'h19; \n"
	result += "  \n"
	result += "  parameter [4:0] A_EIE      = 5'h1B; //parameter [4:0] A_EIE     = 5'h1B; /parameter [4:0] A_EIE     = 5'h1B;  parameter [4:0] A_EIE   = 5'h1B; \n"
	result += "  parameter [4:0] A_EIR      = 5'h1C; //parameter [4:0] A_EIR     = 5'h1C; parameter [4:0] A_EIR     = 5'h1C;  parameter [4:0] A_EIR   = 5'h1C; \n"
	result += "  parameter [4:0] A_ESTAT    = 5'h1D; //parameter [4:0] A_ESTAT   = 5'h1D; parameter [4:0] A_ESTAT   = 5'h1D;  parameter [4:0] A_ESTAT = 5'h1D; \n"
	result += "  parameter [4:0] A_ECON2    = 5'h1E; //parameter [4:0] A_ECON2   = 5'h1E; parameter [4:0] A_ECON2   = 5'h1E;  parameter [4:0] A_ECON2 = 5'h1E; \n"
	result += "  parameter [4:0] A_ECON1    = 5'h1F; //parameter [4:0] A_ECON1   = 5'h1F; parameter [4:0] A_ECON1   = 5'h1F;  parameter [4:0] A_ECON1 = 5'h1F; \n"
	result += "\n"
	result += "\n"
	result += "  parameter [4:0] A_PHCON1	 = 5'h00;\n"
	result += "  parameter [4:0] A_PHSTAT1	 = 5'h01;\n"
	result += "  parameter [4:0] A_PHHID1	 = 5'h02;\n"
	result += "  parameter [4:0] A_PHHID2	 = 5'h03;\n"
	result += "  parameter [4:0] A_PHCON2	 = 5'h10;\n"
	result += "  parameter [4:0] A_PHSTAT2	 = 5'h11;\n"
	result += "  parameter [4:0] A_PHIE	 = 5'h12;\n"
	result += "  parameter [4:0] A_PHIR	 = 5'h13;\n"
	result += "  parameter [4:0] A_PHLCON	 = 5'h14;\n"
	result += "  \n"
	result += "  //Define the command\n"
	result += "  parameter [2:0] RCR = 3'b000;\n"
	result += "  parameter [2:0] RBM = 3'b001;\n"
	result += "  parameter [2:0] WCR = 3'b010;\n"
	result += "  parameter [2:0] WBM = 3'b011;\n"
	result += "  parameter [2:0] BFS = 3'b100;\n"
	result += "  parameter [2:0] BFC = 3'b101;\n"
	result += "  parameter [2:0] SRC = 3'b111;\n"
	result += "    \n"
	result += "  //LENGTH FRAME ETHENET\n"
	result += "  parameter [9:0] ETHERNET_LENGTH = 10'd" + strconv.Itoa(256+24+int(sl.Config.Rsize)) + ";\n"
	return result
}
func (sl *Etherbond_extra) StaticVerilog() string {

	result := "\n"
	result += "`timescale 1ns / 1ps\n"
	result += "//////////////////////////////////////////////////////////////////////////////////\n"
	result += "// Company: \n"
	result += "// Engineer: \n"
	result += "// \n"
	result += "// Create Date: 03.08.2016 13:40:57\n"
	result += "// Design Name: \n"
	result += "// Module Name: TopModuleSPI\n"
	result += "// Project Name: \n"
	result += "// Target Devices: \n"
	result += "// Tool Versions: \n"
	result += "// Description: \n"
	result += "// \n"
	result += "// Dependencies: \n"
	result += "// \n"
	result += "// Revision:\n"
	result += "// Revision 0.01 - File Created\n"
	result += "// Additional Comments:\n"
	result += "// \n"
	result += "//////////////////////////////////////////////////////////////////////////////////\n"
	result += "\n"
	result += "module TopModuleSPI(\n"
	result += "    input CLOCK,\n"
	result += "    output SCK,\n"
	result += "    output MOSI,\n"
	result += "    output CS_n,\n"
	result += "    input MISO,\n"
	result += "    //control signal\n"
	result += "    input reset_n,\n"
	result += "    input start_conf,\n"
	result += "    output end_conf,\n"
	result += "    input [ETHERNET_LENGTH-1:0] EthTx, \n"
	result += "    input start_write,\n"
	result += "    output done_write,\n"
	result += "    input start_rx,\n"
	result += "    output done_rx,\n"
	result += "    output reg [ETHERNET_LENGTH-1:0] EthRx\n"
	result += "    );\n"
	result += "        \n"
	result += "  //Input command\n"
	result += "  reg [7:0] input_cmd;  \n"
	result += "    \n"
	result += "  //Instruction register    \n"
	result += "  reg [17:0] instruction_reg [0:121];\n"
	result += "  \n"
	result += "  //Instruction write\n"
	result += "  reg [17:0] instruction_write [0:12];\n"
	result += "\n"
	result += "  //Instruction rx\n"
	result += "  reg [17:0] instruction_rx [0:25];\n"
	result += "    \n"
	result += "  //control reg \n"
	result += "  (* keep=\"true\" *) reg [31:0] control_reg [0:3][0:31]; \n"
	result += "  (* keep=\"true\" *) wire mistat_busy = control_reg[3][10][0];\n"
	result += "    \n"
	result += "  initial begin\n"
	result += "    //soft reset\n"
	result += "    instruction_reg[0]   = {SRC, 5'b11111,      2'b00, 8'h00};              \n"
	result += "    \n"
	result += "    //Clear ECON1 spi_write_op(priv, ENC28J60_WRITE_CTRL_REG, ECON1, 0x00);\n"
	result += "    instruction_reg[1]   = {WCR, A_ECON1,      2'b00, 8'h00};        \n"
	result += "    \n"
	result += "    //Set ECON2 nolock_regb_write(priv, ECON2, ECON2_AUTOINC | ECON2_VRPS);        \n"
	result += "    instruction_reg[2]   = {WCR, A_ECON2,      2'b00, 8'h80};        \n"
	result += "    \n"
	result += "    //Check    \n"
	result += "    instruction_reg[3]   = {BFS, A_ECON1,    2'b00, 8'h03};    //Set bank 3\n"
	result += "    instruction_reg[4]   = {RCR, A_EREVID,   2'b11, 8'h00};   \n"
	result += "    \n"
	result += "    //rxfifo initialization\n"
	result += "    instruction_reg[5]   = {BFC, A_ECON1,    2'b00, 8'h03};        //Set bank 0\n"
	result += "    instruction_reg[6]   = {WCR, A_ERXSTL,   2'b00, 8'h00};   //nolock_regw_write(priv, ERXSTL, start);\n"
	result += "    instruction_reg[7]   = {WCR, A_ERXSTH,   2'b00, 8'h00};\n"
	result += "    instruction_reg[8]   = {WCR, A_ERXRDPTL, 2'b00, 8'hFF};   //nolock_regw_write(priv, ERXRDPTL, erxrdpt);\n"
	result += "    instruction_reg[9]   = {WCR, A_ERXRDPTH, 2'b00, 8'h19}; \n"
	result += "    instruction_reg[10]  = {WCR, A_ERXNDL,   2'b00, 8'hFF};  //nolock_regw_write(priv, ERXNDL, end);\n"
	result += "    instruction_reg[11]  = {WCR, A_ERXNDH,   2'b00, 8'h19};\n"
	result += "    \n"
	result += "    //in configurazione tx_fifo\n"
	result += "    instruction_reg[12]  = {WCR, A_ETXSTL,   2'b00, 8'h00};  //nolock_regw_write(priv, ETXSTL, start);\n"
	result += "    instruction_reg[13]  = {WCR, A_ETXSTH,   2'b00, 8'h1A};\n"
	result += "    instruction_reg[14]  = {WCR, A_ETXNDL,   2'b00, 8'hFF};  //nolock_regw_write(priv, ETXNDL, end);\n"
	result += "    instruction_reg[15]  = {WCR, A_ETXNDH,   2'b00, 8'h1F};\n"
	result += "    \n"
	result += "    //Set ERXFCON locked_regb_write(priv, ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN);\n"
	result += "    instruction_reg[16]  = {BFS, A_ECON1,      2'b00, 8'h01};        //Set bank 2\n"
	result += "    instruction_reg[17]  = {WCR, A_ERXFCON,  2'b01, 8'h61};        \n"
	result += "    \n"
	result += "    instruction_reg[18]  = {BFC, A_ECON1,      2'b00, 8'h03};        //Set bank 2\n"
	result += "    instruction_reg[19]  = {BFS, A_ECON1,      2'b00, 8'h02};        //Set bank 2\n"
	result += "    instruction_reg[20]  = {WCR, A_MACON1,      2'b10, 8'h0D};        //locked_regb_write(priv, MACON1, MACON1_MARXEN | MACON1_TXPAUS | MACON1_RXPAUS);\n"
	result += "    instruction_reg[21]  = {WCR, A_MACON3,      2'b10, 8'h33};        //locked_regb_write(priv, MACON3, MACON3_PADCFG0 | MACON3_TXCRCEN | MACON3_FRMLNEN | MACON3_FULDPX);\n"
	result += "    instruction_reg[22]  = {WCR, A_MAIPGL,      2'b10, 8'h12};        //locked_regb_write(priv, MAIPGL, 0x12);\n"
	result += "    instruction_reg[23]  = {WCR, A_MABBIPG,  2'b10, 8'h15};        //locked_regb_write(priv, MABBIPG, 0x15);\n"
	result += "    instruction_reg[24]  = {WCR, A_MAMXFLL,  2'b10, 8'hEE};        //locked_regw_write(priv, MAMXFLL, MAX_FRAMELEN);\n"
	result += "    instruction_reg[25]  = {WCR, A_MAMXFLH,  2'b10, 8'h05};        //LENGTH OF ETH FRAME (1518) \n"
	result += "\n"
	result += "      \n"
	result += "    //configure LEDs\n"
	result += "    instruction_reg[26]  = {WCR, A_MIREGADR, 2'b10, 3'b0, 5'b10100};//A_PHLCON};   //nolock_regb_write(priv, MIREGADR, address);\n"
	result += "    instruction_reg[27]  = {WCR, A_MIWRL,    2'b10, 8'h74}; // nolock_regw_write(priv, MIWRL, data);\n"
	result += "    instruction_reg[28]  = {WCR, A_MIWRH,    2'b10, 8'h34};      \n"
	result += "    instruction_reg[29]  = {BFS, A_ECON1,    2'b10, 8'h03};    //Set bank 3    \n"
	result += "    instruction_reg[30]  = {RCR, A_MISTAT,   2'b11, 8'h00};   //poll_ready(priv, MISTAT, MISTAT_BUSY, 0)\n"
	result += "        \n"
	result += "    instruction_reg[31]  = {BFC, A_ECON1,      2'b10, 8'h03};          //Set bank 2\n"
	result += "    instruction_reg[32]  = {BFS, A_ECON1,      2'b10, 8'h02};          //Set bank 2\n"
	result += "    instruction_reg[33]  = {WCR, A_MIREGADR, 2'b10, 3'b0, 5'b00000};// A_PHCON1};   //nolock_regb_write(priv, MIREGADR, address);\n"
	result += "    instruction_reg[34]  = {WCR, A_MIWRL,    2'b10, 8'h00}; // nolock_regw_write(priv, MIWRL, data);\n"
	result += "    instruction_reg[35]  = {WCR, A_MIWRH,    2'b10, 8'h01};      \n"
	result += "    instruction_reg[36]  = {BFS, A_ECON1,    2'b10, 8'h03};    //Set bank 3    \n"
	result += "    instruction_reg[37]  = {RCR, A_MISTAT,   2'b11, 8'h00};   //poll_ready(priv, MISTAT, MISTAT_BUSY, 0) \n"
	result += "\n"
	result += "    instruction_reg[38]  = {BFC, A_ECON1,      2'b10, 8'h03};          //Set bank 2\n"
	result += "    instruction_reg[39]  = {BFS, A_ECON1,      2'b10, 8'h02};          //Set bank 2\n"
	result += "    instruction_reg[40]  = {WCR, A_MIREGADR, 2'b10, 3'b0, 5'b10000};//A_PHCON2};   //nolock_regb_write(priv, MIREGADR, address);\n"
	result += "    instruction_reg[41]  = {WCR, A_MIWRL,    2'b10, 8'h00}; // nolock_regw_write(priv, MIWRL, data);\n"
	result += "    instruction_reg[42]  = {WCR, A_MIWRH,    2'b10, 8'h00};      \n"
	result += "    instruction_reg[43]  = {BFS, A_ECON1,    2'b10, 8'h03};    //Set bank 3    \n"
	result += "    instruction_reg[44]  = {RCR, A_MISTAT,   2'b11, 8'h00};   //poll_ready(priv, MISTAT, MISTAT_BUSY, 0) \n"
	result += "    \n"
	result += "    \n"
	result += "    //\n"
	result += "    instruction_reg[45]  = {BFC, A_ECON1,      2'b10, 8'h03};          //Set bank 2\n"
	result += "    instruction_reg[46]  = {BFS, A_ECON1,      2'b10, 8'h02};          //Set bank 2\n"
	result += "    instruction_reg[47]  = {WCR, A_MIREGADR, 2'b10, 3'b0,  5'b10010};//A_PHIE};   //nolock_regb_write(priv, MIREGADR, address);\n"
	result += "    instruction_reg[48]  = {WCR, A_MIWRL,      2'b10, 8'h12}; // nolock_regw_write(priv, MIWRL, data);\n"
	result += "    instruction_reg[49]  = {RCR, A_MIWRL,    2'b10, 8'h00};\n"
	result += "    instruction_reg[50]  = {WCR, A_MIWRH,      2'b10, 8'h00};      \n"
	result += "    instruction_reg[51]  = {RCR, A_MIWRH,    2'b10, 8'h00};   \n"
	result += "    instruction_reg[52]  = {BFS, A_ECON1,      2'b10, 8'h03};        //Set bank 3    \n"
	result += "    instruction_reg[53]  = {RCR, A_MISTAT,      2'b11, 8'h00};  //    poll_ready(priv, MISTAT, MISTAT_BUSY, 0) ? 0 : 1;  ?????LEGGO IL BIT 0 NEL CASO ? 0 POSSO ANDARE AVANTI ALTRIMENTI ASPETTO?????\n"
	result += "          \n"
	result += "    //configurare per la scrittura del dato\n"
	result += "    //nolock_regw_write(priv, EWRPTL, EWRPTH, 16'h1A00);\n"
	result += "    \n"
	result += "    //enable interrupt\n"
	result += "    instruction_reg[54]  = {BFC, A_ECON1,      2'b10, 8'h03};          //Set bank 2\n"
	result += "    instruction_reg[55]  = {BFS, A_ECON1,      2'b10, 8'h02};          //Set bank 2\n"
	result += "    instruction_reg[56]  = {WCR, A_MIREGADR, 2'b10, 3'b0, 5'b10010};//A_PHIE};   //nolock_regb_write(priv, MIREGADR, address);\n"
	result += "    instruction_reg[57]  = {WCR, A_MIWRL,    2'b10, 8'h12}; // nolock_regw_write(priv, MIWRL, data);\n"
	result += "    instruction_reg[58]  = {WCR, A_MIWRH,    2'b10, 8'h00};      \n"
	result += "    instruction_reg[59]  = {BFS, A_ECON1,    2'b10, 8'h03};    //Set bank 3    \n"
	result += "    instruction_reg[60]  = {RCR, A_MISTAT,   2'b11, 8'h00};   //poll_ready(priv, MISTAT, MISTAT_BUSY, 0)\n"
	result += "\n"
	result += "    instruction_reg[61]  = {BFC, A_ECON1,      2'b00, 8'h03};        //Set bank 0\n"
	result += "    instruction_reg[62]  = {BFC, A_EIR,      2'b00, 8'h7B};        //nolock_reg_bfclr(priv, EIR, EIR_DMAIF | EIR_LINKIF | EIR_TXIF | EIR_TXERIF | EIR_RXERIF | EIR_PKTIF);\n"
	result += "    instruction_reg[63]  = {WCR, A_EIE,      2'b00, 8'h00};        //nolock_regb_write(priv, EIE, EIE_INTIE | EIE_PKTIE | EIE_LINKIE | EIE_TXIE | EIE_TXERIE | EIE_RXERIE);\n"
	result += "    instruction_reg[64]  = {RCR, A_EIE,      2'b00, 8'h00};\n"
	result += "    instruction_reg[65]  = {BFS, A_ECON1,      2'b00, 8'h00};        //nolock_reg_bfset(priv, ECON1, ECON1_RXEN);\n"
	result += "    \n"
	result += "    //read PHY\n"
	result += "    instruction_reg[66]  = {BFC, A_ECON1,      2'b10, 8'h03};          //Set bank 2\n"
	result += "    instruction_reg[67]  = {BFS, A_ECON1,      2'b10, 8'h02};          //Set bank 2\n"
	result += "    instruction_reg[68]  = {WCR, A_MIREGADR, 2'b10, 3'b0, 5'b10001};//A_PHSTAT2};   //nolock_regb_write(priv, MIREGADR, address);\n"
	result += "    instruction_reg[69]  = {WCR, A_MICMD,    2'b10, 8'h01}; \n"
	result += "    instruction_reg[70]  = {BFS, A_ECON1,    2'b10, 8'h03};    //Set bank 3   \n"
	result += "    instruction_reg[71]  = {RCR, A_MISTAT,   2'b11, 8'h00};   //poll_ready(priv, MISTAT, MISTAT_BUSY, 0)\n"
	result += "    instruction_reg[72]  = {BFC, A_ECON1,      2'b10, 8'h03};          //Set bank 2\n"
	result += "    instruction_reg[73]  = {BFS, A_ECON1,      2'b10, 8'h02};          //Set bank 2\n"
	result += "    instruction_reg[74]  = {WCR, A_MICMD,    2'b10, 8'h00}; \n"
	result += "    instruction_reg[75]  = {RCR, A_MIRDL,    2'b10, 8'h12}; // nolock_regw_write(priv, MIWRL, data);\n"
	result += "    instruction_reg[76]  = {RCR, A_MIRDH,    2'b10, 8'h00};      \n"
	result += "   \n"
	result += "    \n"
	result += "    //dump regisri\n"
	result += "    //instruction_reg[75]   = {RCR, A_ECON2,     2'b00, 8'h00};\n"
	result += "    //instruction_reg[76]   = {RCR, A_ESTAT,     2'b00, 8'h00};  \n"
	result += "    instruction_reg[77]   = {RCR, A_EIR,       2'b00, 8'h00};  \n"
	result += "    instruction_reg[78]   = {RCR, A_EIE,       2'b00, 8'h00};  \n"
	result += "    instruction_reg[79]   = {RCR, A_ERXSTL,    2'b00, 8'h00};  \n"
	result += "    instruction_reg[80]   = {RCR, A_ERXSTH,    2'b00, 8'h00};  \n"
	result += "    instruction_reg[81]   = {RCR, A_ERXNDL,    2'b00, 8'h00};  \n"
	result += "    instruction_reg[82]   = {RCR, A_ERXNDH,    2'b00, 8'h00}; \n"
	result += "    instruction_reg[83]   = {RCR, A_ERXWRPTL,  2'b00, 8'h00};  \n"
	result += "    instruction_reg[84]   = {RCR, A_ERXWRPTH,  2'b00, 8'h00};  \n"
	result += "    instruction_reg[85]   = {RCR, A_ERXRDPTL,  2'b00, 8'h00};  \n"
	result += "    instruction_reg[86]   = {RCR, A_ERXRDPTH,  2'b00, 8'h00};  \n"
	result += "    instruction_reg[87]   = {RCR, A_ETXSTL,    2'b00, 8'h00};\n"
	result += "    instruction_reg[88]   = {RCR, A_ETXSTH,    2'b00, 8'h00};  \n"
	result += "    instruction_reg[89]   = {RCR, A_ETXNDL,    2'b00, 8'h00};  \n"
	result += "    instruction_reg[90]   = {RCR, A_ETXNDH,    2'b00, 8'h00}; \n"
	result += "\n"
	result += "    instruction_reg[91]  = {BFC, A_ECON1,       2'b01, 8'h03};          //Set bank 2\n"
	result += "    instruction_reg[92]  = {BFS, A_ECON1,       2'b01, 8'h01};          //Set bank 1\n"
	result += "    instruction_reg[93]   = {RCR, A_ERXFCON,   2'b01, 8'h00}; \n"
	result += "\n"
	result += "    instruction_reg[94]  = {BFC, A_ECON1,       2'b10, 8'h03};          //Set bank 2\n"
	result += "    instruction_reg[95]  = {BFS, A_ECON1,       2'b10, 8'h02};          //Set bank 2\n"
	result += "    instruction_reg[96]   = {RCR, A_MACON1,    2'b10, 8'h00};  \n"
	result += "    instruction_reg[97]   = {RCR, A_MACON3,    2'b10, 8'h00};  \n"
	result += "    instruction_reg[98]   = {RCR, A_MACON4,    2'b10, 8'h00}; \n"
	result += "    instruction_reg[99]   = {RCR, A_MAMXFLL,   2'b10, 8'h00};\n"
	result += "    instruction_reg[100]   = {RCR, A_MAMXFLH,   2'b10, 8'h00};      \n"
	result += "    instruction_reg[101]   = {RCR, A_MACLCON1,  2'b10, 8'h00};  \n"
	result += "    //instruction_reg[102]   = {RCR, A_MACLCON2,  2'b10, 8'h00}; \n"
	result += "\n"
	result += "    instruction_reg[102]  = {WCR, A_MAADR1,      2'b11, MYMAC_6};\n"
	result += "    instruction_reg[103]  = {WCR, A_MAADR2,      2'b11, MYMAC_5};\n"
	result += "    instruction_reg[104]  = {WCR, A_MAADR3,      2'b11, MYMAC_4};\n"
	result += "    instruction_reg[105]  = {WCR, A_MAADR4,      2'b11, MYMAC_3};\n"
	result += "    instruction_reg[106]  = {WCR, A_MAADR5,      2'b11, MYMAC_2};\n"
	result += "    instruction_reg[107]  = {WCR, A_MAADR6,      2'b11, MYMAC_1};\n"
	result += "\n"
	result += "    instruction_reg[108]  = {BFS, A_ECON1,      2'b00, 8'h04};  //nolock_reg_bfset(priv, ECON1, ECON1_RXEN);\n"
	result += "    instruction_reg[109]   = {WCR, A_EPMOL,      2'b01, 8'h0C};\n"
	result += "    instruction_reg[110]   = {WCR, A_EPMOH,      2'b01, 8'h00};\n"
	result += "    instruction_reg[111]   = {WCR, A_EPMM0,      2'b01, 8'h0C};\n"
	result += "    instruction_reg[112]   = {WCR, A_EPMM1,      2'b01, 8'h00};\n"
	result += "    instruction_reg[113]   = {WCR, A_EPMM2,      2'b01, 8'h00};\n"
	result += "    instruction_reg[114]   = {WCR, A_EPMM3,      2'b01, 8'h00};\n"
	result += "    instruction_reg[115]  = {WCR, A_EPMM4,      2'b01, 8'h00};\n"
	result += "    instruction_reg[116]  = {WCR, A_EPMM5,      2'b01, 8'h00};\n"
	result += "    instruction_reg[117]  = {WCR, A_EPMM6,      2'b01, 8'h00};\n"
	result += "    instruction_reg[118]  = {WCR, A_EPMM7,      2'b01, 8'h00};\n"
	result += "    instruction_reg[119]  = {WCR, A_EPMCSL,     2'b01, 8'h77};\n"
	result += "    instruction_reg[120]  = {WCR, A_EPMCSH,     2'b01, 8'h77};\n"
	result += "    instruction_reg[121]  = {RCR, A_ECON1,      2'b00, 8'h04}; //nolock_reg_bfset(priv, ECON1, ECON1_RXEN);\n"
	result += "\n"
	result += "    \n"
	result += "    end\n"
	result += "    //$readmemh(\"file\", name)\n"
	result += "          \n"
	result += "  (* keep=\"true\" *) wire [ETHERNET_LENGTH-1:0] rdata_spi;\n"
	result += "  \n"
	result += "  //different start signal to spi module  \n"
	result += "  wire start_spi;\n"
	result += "  \n"
	result += "  reg start_pulse, start_pulse_write, start_pulse_rx;\n"
	result += "  reg [4:0] delay;\n"
	result += "  (* keep=\"true\" *) reg [6:0] count_reg_write;\n"
	result += "  (* keep=\"true\" *) reg [6:0] count_reg_spi;\n"
	result += "  (* keep=\"true\" *) reg [6:0] count_reg_rx;\n"
	result += "    \n"
	result += "	always@(posedge CLOCK)\n"
	result += "	begin\n"
	result += "		if(reset_n==0 | CS_n == 0)  \n"
	result += "		  delay <= 'b0;\n"
	result += "		else if(CS_n & (start_conf | start_write | start_rx))  \n"
	result += "		  delay <= delay + 1'b1;\n"
	result += "	end\n"
	result += "	\n"
	result += "	reg stop_counter;\n"
	result += "	always@(posedge CLOCK)\n"
	result += "  begin\n"
	result += "    if(reset_n==0)  \n"
	result += "      stop_counter <= 'b0;\n"
	result += "    else if(count_reg_spi==7'b1111001 & done_spi)  \n"
	result += "      stop_counter <= 1'b1;\n"
	result += "  end	\n"
	result += "	    	\n"
	result += "	always@(posedge CLOCK or negedge reset_n) \n"
	result += "	begin\n"
	result += "		if(reset_n==0) begin  \n"
	result += "		  count_reg_spi <= 7'b1111111;\n"
	result += "		  start_pulse <= 1'b0; \n"
	result += "		end\n"
	result += "		else if(CS_n==0) begin\n"
	result += "		  start_pulse <= 1'b0;        \n"
	result += "		end\n"
	result += "		else if(delay == 5'b11111 & !stop_counter) begin\n"
	result += "		  if(instruction_reg[count_reg_spi][14:8] == {A_MISTAT, 2'b11}) begin\n"
	result += "		    if(mistat_busy==1'b0) begin\n"
	result += "		      start_pulse <= 1'b1;\n"
	result += "          count_reg_spi <= count_reg_spi + 1'b1;\n"
	result += "        end  \n"
	result += "		  end\n"
	result += "		  else begin\n"
	result += "		    start_pulse <= 1'b1;\n"
	result += "		    count_reg_spi <= count_reg_spi + 1'b1;\n"
	result += "		  end\n"
	result += "		end \n"
	result += "	end\n"
	result += "  \n"
	result += "  wire [7:0] cmd2spi;\n"
	result += "  assign cmd2spi = (stop_counter==1'b0) ? instruction_reg[count_reg_spi][17:10] : ((start_write==1'b1) ? instruction_write[count_reg_write][17:10] : ((start_rx==1'b1) ? instruction_rx[count_reg_rx][17:10] : 'b0)); \n"
	result += "  \n"
	result += "  wire [7:0] spi_data_in; //cambiare con dimensione massima\n"
	result += "  assign spi_data_in = (stop_counter==1'b0) ? instruction_reg[count_reg_spi][7:0] : ((start_write==1'b1) ? instruction_write[count_reg_write][7:0] : ((start_rx==1'b1) ? instruction_rx[count_reg_rx][7:0] : 'b0)); \n"
	result += "  \n"
	result += "  assign start_spi = (start_conf==1'b1) ? start_pulse : ((start_write==1'b1) ? start_pulse_write : ((start_rx==1'b1) ? start_pulse_rx : 'b0)); \n"
	result += " \n"
	result += "	spi_master spi_master_inst\n"
	result += "	(   \n"
	result += "     .rstb(reset_n) \n"
	result += "      ,.clk(CLOCK)\n"
	result += "      ,.cmd(cmd2spi)\n"
	result += "      ,.start(start_spi) \n"
	result += "      ,.tdat(spi_data_in)\n"
	result += "      ,.wdata(EthTx)\n"
	result += "      ,.cdiv(2'b11)\n"
	result += "      ,.din(MISO)\n"
	result += "      ,.ss(CS_n)\n"
	result += "      ,.sck(SCK)\n"
	result += "      ,.dout(MOSI)\n"
	result += "      ,.done(done_spi)\n"
	result += "      ,.rdata(rdata_spi)\n"
	result += "      //numero of shift\n"
	result += "      ,.n_shift_RBM(instruction_rx[count_reg_rx][9:0])\n"
	result += "	);\n"
	result += "\n"
	result += "	\n"
	result += "	//LO POSSO METTERE CON IL CLOCK SFRUTTANDO IL DONE\n"
	result += "	integer i,j;\n"
	result += "	always@(posedge CLOCK) begin\n"
	result += "	 if(reset_n==0) begin\n"
	result += "	   for (i = 0; i < 4; i = i +1) begin\n"
	result += "	     for (j = 0; j < 32; j = j +1) begin\n"
	result += "	       control_reg[i][j] <= 'b0; \n"
	result += "	     end\n"
	result += "	   end\n"
	result += "	 end  \n"
	result += "		if(done_spi) begin\n"
	result += "		  if(instruction_reg[count_reg_spi][17:15]==RCR)\n"
	result += "		     for (i = 0; i < 4; i = i +1) begin\n"
	result += "            for (j = 0; j < 32; j = j +1) begin  \n"
	result += "              if(i==instruction_reg[count_reg_spi][9:8] & j==instruction_reg[count_reg_spi][14:10])\n"
	result += "                  control_reg[i][j] <= rdata_spi[31:0]; \n"
	result += "            end\n"
	result += "         end      \n"
	result += "		  end\n"
	result += "	 end\n"
	result += "	\n"
	result += "	//assign the bit for controlling the PHY status\n"
	result += "	\n"
	result += "	\n"
	result += "	//assign end of configuration\n"
	result += "	assign end_conf = stop_counter;\n"
	result += "  \n"
	result += "  wire stop_write_internal = (count_reg_write==7'b0001011) ? 1'b1 : 1'b0;\n"
	result += "  wire stop_write = start_write & done_spi & stop_write_internal; \n"
	result += "  assign done_write = stop_write;\n"
	result += "\n"
	result += "  always@(posedge CLOCK) \n"
	result += "	begin\n"
	result += "		if(reset_n==0 | stop_write) begin  \n"
	result += "		  count_reg_write <= 7'b1111111;\n"
	result += "		  start_pulse_write <= 1'b0; \n"
	result += "		end\n"
	result += "		else if(CS_n==0) begin\n"
	result += "		  start_pulse_write <= 1'b0;        \n"
	result += "		end\n"
	result += "		else if(delay == 5'b11111 & start_write) begin\n"
	result += "		  start_pulse_write <= 1'b1;\n"
	result += "      count_reg_write <= count_reg_write + 1'b1;\n"
	result += "    end  \n"
	result += "	end\n"
	result += "	\n"
	result += "	\n"
	result += "  initial begin	\n"
	result += "	  \n"
	result += "	instruction_write[0]  = {BFC, A_ECON1, 	  2'b00, 8'h03};  //Set bank 0	\n"
	result += "	instruction_write[1]  = {RCR, A_ECON1, 	  2'b00, 8'h00};  //Set bank 0	\n"
	result += "	  \n"
	result += "	instruction_write[2]  = {WCR, A_EWRPTL,   2'b00, 8'h00};  //nolock_regw_write(priv, ETXSTL, start);\n"
	result += "    instruction_write[3]  = {WCR, A_EWRPTH,   2'b00, 8'h1A};\n"
	result += "	instruction_write[4]  = {RCR, A_EWRPTL,   2'b00, 8'h00};  //Read\n"
	result += "	instruction_write[5]  = {RCR, A_EWRPTH,   2'b00, 8'h00};  //Read	\n"
	result += "    //mettere la lunghezza\n"
	result += "	  //1 byte per packet : 00\n"
	result += "    //5 byte per DA : FF-FF-FF-FF-FF\n"
	result += "    //5 byte per SA : 01-02-03-04-05\n"
	result += "    //2 byte Type   : 8888\n"
	result += "    //2 byte Data   : ABCD\n"
	result += "    //1 byte Data	: ethBM\n"
	result += "    //length 16 => 1A10\n"
	result += "    instruction_write[6]  = {WCR, A_ETXNDL,   2'b00, 8'h45};  //nolock_regw_write(priv, ETXNDL, end);\n"
	result += "    instruction_write[7]  = {WCR, A_ETXNDH,   2'b00, 8'h1A};\n"
	result += "   \n"
	result += "    // write per-packet control byte \n"
	result += "    instruction_write[8]  = {WBM, 5'b11010,   2'b00, 8'h00};\n"
	result += "	instruction_write[9]  = {RCR, A_EWRPTL,   2'b00, 8'h00};  //Read\n"
	result += "	instruction_write[10]  = {RCR, A_EWRPTH,   2'b00, 8'h00};  //Read	\n"
	result += "	\n"
	result += "    /*4. Clear EIR.TXIF, set EIE.TXIE and set EIE.INTIE to enable an interrupt when done (if desired).*/\n"
	result += "    //instruction_write[11]  = {BFC, A_EIR,   2'b00, 8'h08}; \n"
	result += "  \n"
	result += "    /*5. Start the transmission process by setting  ECON1.TXRTS.*/\n"
	result += "    instruction_write[11]  = {BFS, A_ECON1, 2'b00, 8'h08};\n"
	result += "  end\n"
	result += "  \n"
	result += "    (* keep=\"true\" *) reg [7:0] rx_pck;\n"
	result += "    //(* keep=\"true\" *) reg [15:0] debeth;\n"
	result += "    (* keep=\"true\" *) reg [15:0] pointer; // new_pointer;\n"
	result += "    always@(posedge CLOCK)\n"
	result += "    begin\n"
	result += "      if(reset_n==0) begin\n"
	result += "          rx_pck <= 'b0;\n"
	result += "      end\n"
	result += "      else  if(count_reg_rx==7'b0001101 & done_spi==1'b1) begin\n"
	result += "           rx_pck <= rdata_spi[7:0];\n"
	result += "        end\n"
	result += "    end\n"
	result += "  \n"
	result += "  wire stop_rx_internal = (count_reg_rx==7'b0010001 & rx_pck=='b0) ? 1'b1 : (count_reg_rx==7'b0011011) ? 1'b1 : 1'b0;\n"
	result += "  wire stop_rx = start_rx & done_spi & stop_rx_internal; \n"
	result += "  assign done_rx = stop_rx;\n"
	result += "\n"

	result += " always@(posedge CLOCK)\n"
	result += "  begin\n"
	result += "    if(reset_n==0 | stop_rx) begin\n"
	result += "      count_reg_rx <= 7'b1111111;\n"
	result += "      start_pulse_rx <= 1'b0;\n"
	result += "    end\n"
	result += "    else if(CS_n==0) begin\n"
	result += "      start_pulse_rx <= 1'b0;\n"
	result += "    end\n"
	result += "    else if(delay == 5'b11111 & start_rx) begin\n"
	result += "      start_pulse_rx <= 1'b1;\n"
	result += "      count_reg_rx <= count_reg_rx + 1'b1;\n"
	result += "    end\n"
	result += "  end\n"
	result += "\n"
	result += "   assign instruction_rx[0]  = {BFC, A_ECON1,      2'b10, 8'h03};          //Set bank 2\n"
	result += "   assign    instruction_rx[1]  = {BFS, A_ECON1,      2'b10, 8'h02};          //Set bank 2\n"
	result += "   assign instruction_rx[2]  = {WCR, A_MIREGADR, 2'b10, 3'b0, A_PHSTAT1};   //nolock_regb_write(priv, MIREGADR, address);\n"
	result += "   assign instruction_rx[3]  = {WCR, A_MICMD,    2'b10, 8'h01};\n"
	result += "   assign instruction_rx[4]  = {BFS, A_ECON1,    2'b10, 8'h03};    //Set bank 3   \n"
	result += "   assign instruction_rx[5]  = {RCR, A_MISTAT,   2'b11, 8'h00};   //poll_ready(priv, MISTAT, MISTAT_BUSY, 0)\n"
	result += "   assign instruction_rx[6]  = {BFC, A_ECON1,      2'b10, 8'h03};          //Set bank 2\n"
	result += "   assign instruction_rx[7]  = {BFS, A_ECON1,      2'b10, 8'h02};          //Set bank 2\n"
	result += "   assign instruction_rx[8]  = {WCR, A_MICMD,    2'b10, 8'h00};\n"
	result += "   assign  instruction_rx[9]  = {RCR, A_MIRDL,    2'b10, 8'h00}; // nolock_regw_write(priv, MIWRL, data);\n"
	result += "   assign instruction_rx[10]  = {RCR, A_MIRDH,    2'b10, 8'h00};\n"
	result += "\n"
	result += "   //check the flag for the interrupt\n"
	result += " //  instruction_rx[1]  = {RCR, A_EIR,         2'b00, 8'h00};        //Set bank 0\n"
	result += "\n"
	result += "\n"
	result += "      assign instruction_rx[11]  = {BFC, A_ECON1,     2'b00, 8'h03};        //Set bank 0\n"
	result += "      assign instruction_rx[12]  = {BFS, A_ECON1,     2'b00, 8'h01};        //Set bank 2\n"
	result += "\n"
	result += "   //read the packet counter\n"
	result += "     assign  instruction_rx[13]  = {RCR, A_EPKTCNT,   2'b00, 8'h00};\n"
	result += "\n"
	result += "       assign instruction_rx[14]  = {BFC, A_ECON1,     2'b00, 8'h03};        //Set bank 0\n"
	result += "\n"
	result += "   assign instruction_rx[15]  = {WCR, A_ERDPTL,    2'b00, pointer[7:0]};\n"
	result += "   assign instruction_rx[16]  = {WCR, A_ERDPTH,    2'b00, pointer[15:8]};\n"
	result += "\n"
	result += "         assign instruction_rx[17]  = {BFC, A_ECON1,     2'b00, 8'h03};        //Set bank 0\n"
	result += "\n"
	result += "   assign instruction_rx[18]  = {RBM, 5'b11010,    10'h038};\n"
	result += "\n"
	result += "\n"
	result += "         assign instruction_rx[19]  = {BFS, A_ECON1,     2'b00, 8'h01};        //Set bank 0\n"
	result += "\n"
	result += "   //assign instruction_rx[20]  = {WCR, A_ERDPTL,    2'b00, new_pointer[7:0]};\n"
	result += "   //   assign instruction_rx[21]  = {WCR, A_ERDPTH,    2'b00, new_pointer[15:8]};\n"
	result += "\n"
	result += "   assign instruction_rx[20]  = {RBM, 5'b11010,    10'h120};\n"
	result += "\n"
	result += "         assign instruction_rx[21]  = {BFC, A_ECON1,     2'b00, 8'h03};        //Set bank 0\n"
	result += "\n"
	result += "     assign instruction_rx[22]  = {WCR, A_ERXRDPTL,  2'b00, pointer[7:0]};\n"
	result += "     assign instruction_rx[23]  = {WCR, A_ERXRDPTH,  2'b00, pointer[15:8]};\n"
	result += "\n"
	result += "\n"
	result += "\n"
	result += "  assign  instruction_rx[24]  = {BFS, A_ECON2,     2'b00, 8'h40};\n"
	result += "\n"
	result += "         assign instruction_rx[25]  = {BFS, A_ECON1,     2'b00, 8'h01};        //Set bank 2\n"
	result += "   //assign instruction_rx[23]  = {RCR, A_EPKTCNT,   2'b01, 8'h00}; \n"
	result += "\n"
	result += "  (* keep = \"true\" *) reg rx_ok;\n"
	result += "  (* keep = \"true\" *) reg [15:0] length_rx;\n"
	result += " //assign rx frame\n"
	result += "  always@(posedge CLOCK)\n"
	result += "  begin\n"
	result += "    if(reset_n==0) begin\n"
	result += "       // debeth <= 'b0;\n"
	result += "        pointer <= 'b0;\n"
	result += "        rx_ok <= 'b0;\n"
	result += "        length_rx <= 'b0;\n"
	result += "  //      new_pointer <= 'b0; \n"
	result += "    end\n"
	result += "    else  if(count_reg_rx==7'b0010010 & done_spi) begin\n"
	result += "     //    debeth <= rdata_spi[119:104];\n"
	result += "         pointer <= {rdata_spi[39:32], rdata_spi[47:40]};\n"
	result += "//         new_pointer <= pointer + 6;\n"
	result += "         rx_ok <= rdata_spi[15];\n"
	result += "         length_rx <= rdata_spi[31:16];\n"
	result += "      end\n"
	result += "  end\n"
	result += "\n"
	result += "  always@(posedge CLOCK)\n"
	result += "    begin\n"
	result += "      if(reset_n==1'b0) begin\n"
	result += "          EthRx <= 'b0;\n"
	result += "      end\n"
	result += "      else  if(count_reg_rx==7'b0010100 & done_spi) begin\n"
	result += "           EthRx <= rdata_spi;\n"
	result += "        end\n"
	result += "    end\n"

	result += "endmodule\n"
	result += "////////////////////////////////////////////////////////////////////////////////\n"
	result += "////                                                                        ////\n"
	result += "//// Project Name: SPI (Verilog)                                            ////\n"
	result += "////                                                                        ////\n"
	result += "//// Module Name: spi_master                                                ////\n"
	result += "////                                                                        ////\n"
	result += "////                                                                        ////\n"
	result += "////  This file is part of the Ethernet IP core project                     ////\n"
	result += "////  http://opencores.com/project,spi_verilog_master_slave                 ////\n"
	result += "////                                                                        ////\n"
	result += "////  Author(s):                                                            ////\n"
	result += "////      Santhosh G (santhg@opencores.org)                                 ////\n"
	result += "////                                                                        ////\n"
	result += "////  Refer to Readme.txt for more information                              ////\n"
	result += "////                                                                        ////\n"
	result += "////////////////////////////////////////////////////////////////////////////////\n"
	result += "////                                                                        ////\n"
	result += "//// Copyright (C) 2014, 2015 Authors                                       ////\n"
	result += "////                                                                        ////\n"
	result += "//// This source file may be used and distributed without                   ////\n"
	result += "//// restriction provided that this copyright statement is not              ////\n"
	result += "//// removed from the file and that any derivative work contains            ////\n"
	result += "//// the original copyright notice and the associated disclaimer.           ////\n"
	result += "////                                                                        ////\n"
	result += "//// This source file is free software; you can redistribute it             ////\n"
	result += "//// and/or modify it under the terms of the GNU Lesser General             ////\n"
	result += "//// Public License as published by the Free Software Foundation;           ////\n"
	result += "//// either version 2.1 of the License, or (at your option) any             ////\n"
	result += "//// later version.                                                         ////\n"
	result += "////                                                                        ////\n"
	result += "//// This source is distributed in the hope that it will be                 ////\n"
	result += "//// useful, but WITHOUT ANY WARRANTY; without even the implied             ////\n"
	result += "//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR                ////\n"
	result += "//// PURPOSE.  See the GNU Lesser General Public License for more           ////\n"
	result += "//// details.                                                               ////\n"
	result += "////                                                                        ////\n"
	result += "//// You should have received a copy of the GNU Lesser General              ////\n"
	result += "//// Public License along with this source; if not, download it             ////\n"
	result += "//// from http://www.opencores.org/lgpl.shtml                               ////\n"
	result += "////                                                                        ////\n"
	result += "////////////////////////////////////////////////////////////////////////////////\n"
	result += "/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
	result += "  SPI MODE 3\n"
	result += "		CHANGE DATA @ NEGEDGE\n"
	result += "		read data @posedge\n"
	result += "\n"
	result += " RSTB-active low asyn reset, CLK-clock, T_RB=0-rx  1-TX, mlb=0-LSB 1st 1-msb 1st\n"
	result += " START=1- starts data transmission cdiv 0=clk/4 1=/8   2=/16  3=/32\n"
	result += "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/\n"
	result += "module spi_master(rstb,clk,n_shift_RBM,start,tdat,cdiv,cmd,din, wdata, ss,sck,dout,done,rdata);\n"
	result += "\n"
	result += "  input rstb,clk,start;\n"
	result += "  input [7:0] cmd;\n"
	result += "  input [7:0] tdat;  //transmit data\n"
	result += "  input [1:0] cdiv;  //clock divider\n"
	result += "	input din;\n"
	result += "	\n"
	result += "	input [9:0] n_shift_RBM;\n"
	result += "	\n"
	result += "	input [ETHERNET_LENGTH-1:0] wdata;\n"
	result += "	\n"
	result += "	output reg ss; \n"
	result += "	output reg sck; \n"
	result += "	output wire dout; \n"
	result += "  output reg done;\n"
	result += "	output reg [ETHERNET_LENGTH-1:0] rdata; //cambiare con lunghezza massima frame eth\n"
	result += "  \n"
	result += "  //FSM state definition\n"
	result += "  parameter idle        = 3'b000;\n"
	result += "  parameter start_con   = 3'b001;		\n"
	result += "  parameter send_op     = 3'b010;\n"
	result += "  parameter read        = 3'b011; \n"
	result += "  parameter write       = 3'b100;\n"
	result += "  parameter stop_con    = 3'b101;  \n"
	result += "  parameter finish      = 3'b110;\n"
	result += " \n"
	result += "  //Regs and wires declaration\n"
	result += "  reg [2:0] cur,nxt;\n"
	result += "	reg [ETHERNET_LENGTH-1+8:0] treg;\n"
	result += "	reg [ETHERNET_LENGTH-1:0] rreg;\n"
	result += "	reg [4:0] mid,cnt;\n"
	result += "	reg shift,clr;\n"
	result += "	reg [9:0] n_shift, nbit;\n"
	result += "\n"
	result += "  //clock divider\n"
	result += "  always@(cdiv)\n"
	result += "  begin\n"
	result += "    case (cdiv)\n"
	result += "        2'b00: mid=2;\n"
	result += "        2'b01: mid=4;\n"
	result += "        2'b10: mid=8;\n"
	result += "        2'b11: mid=16;\n"
	result += "    endcase\n"
	result += "  end\n"
	result += " \n"
	result += "  \n"
	result += "   always@(negedge clk or negedge rstb) \n"
	result += "   begin\n"
	result += "     if(rstb == 0) \n"
	result += "       n_shift <= 10'h010;\n"
	result += "     else if(cmd[7:5]==RCR)\n"
	result += "       n_shift <= 10'b0000011000;\n"
	result += "     else if(cmd[7:5]==WCR | cmd[7:5]==BFS | cmd[7:5]==BFC)\n"
	result += "       n_shift <= 10'b0000010000;       \n"
	result += "     else if(cmd[7:5]==RBM)\n"
	result += "       n_shift <= n_shift_RBM;\n"
	result += "     else if(cmd[7:5]==WBM)\n"
	result += "       n_shift <= 10'h230;\n"
	result += "   end\n"
	result += "\n"
	result += "  //state transistion\n"
	result += "  always@(negedge clk or negedge rstb) \n"
	result += "  begin\n"
	result += "    if(rstb == 0) \n"
	result += "      cur <= finish;\n"
	result += "    else \n"
	result += "      cur <= nxt;\n"
	result += "  end\n"
	result += "\n"
	result += "   \n"
	result += "  //FSM state\n"
	result += "  always @(start or cur or nbit or rreg or cmd or n_shift or sck) \n"
	result += "  begin\n"
	result += "    nxt <= cur;\n"
	result += "    case(cur)\n"
	result += "      idle:begin\n"
	result += "        if(start)\n"
	result += "          nxt <= start_con;	 \n"
	result += "        end //idle\n"
	result += "      start_con: begin\n"
	result += "        nxt <= send_op;\n"
	result += "      end \n"
	result += "      send_op:begin\n"
	result += "        if(nbit==8) begin\n"
	result += "          if(cmd[7:5]==RCR) \n"
	result += "            nxt <= read; //controllo per write o read\n"
	result += "          else if(cmd[7:5]==WCR) \n"
	result += "            nxt <= write; //controllo per write o read\n"
	result += "          else if(cmd[7:5]==BFS) \n"
	result += "            nxt <= write; //controllo per write o read\n"
	result += "          else if(cmd[7:5]==BFC) \n"
	result += "            nxt <= write; //controllo per write o read\n"
	result += "          else if(cmd[7:5]==RBM) \n"
	result += "            nxt <= read; //controllo per write o read\n"
	result += "          else if(cmd[7:5]==WBM) \n"
	result += "            nxt <= write; //controllo per write o read \n"
	result += "          else if(cmd[7:5]==SRC) \n"
	result += "            nxt <= stop_con; //controllo per write o read                               \n"
	result += "        end\n"
	result += "      end//send_op\n"
	result += "      read:begin\n"
	result += "        if(nbit==n_shift)\n"
	result += "          nxt <= stop_con; //controllo per write o read\n"
	result += "      end//read\n"
	result += "      write:begin\n"
	result += "        if(nbit==n_shift)  \n"
	result += "          nxt <= stop_con; //controllo per write o read\n"
	result += "      end//read\n"
	result += "      stop_con:begin\n"
	result += "        if(sck==1'b0)  \n"
	result += "          nxt <= finish;\n"
	result += "      end\n"
	result += "      finish:begin\n"
	result += "        nxt <= idle;\n"
	result += "      end\n"
	result += "      default: nxt<=finish;\n"
	result += "    endcase\n"
	result += "  end//always\n"
	result += "\n"
	result += "  //FSM state i/o\n"
	result += "  always @(negedge clk) \n"
	result += "  begin\n"
	result += "    case(cur)\n"
	result += "      idle:begin\n"
	result += "        ss <= 1'b1;\n"
	result += "        shift <= 1'b0;\n"
	result += "        done <= 1'b0;\n"
	result += "        clr <= 1'b0;\n"
	result += "      end //idle\n"
	result += "      start_con: begin\n"
	result += "        shift <= 1'b1;\n"
	result += "      end\n"
	result += "      send_op:begin                \n"
	result += "        ss <= 1'b0;\n"
	result += "        shift <= 1'b1;\n"
	result += "        done <= 1'b0;\n"
	result += "        clr <= 1'b0;               \n"
	result += "      end//send_op\n"
	result += "      read:begin\n"
	result += "        shift <= 1'b1; \n"
	result += "        ss <= 1'b0;\n"
	result += "        done <= 1'b0;\n"
	result += "        clr <= 1'b0;                 \n"
	result += "      end//read\n"
	result += "      write:begin\n"
	result += "        shift <= 1'b1; \n"
	result += "        ss <= 1'b0;\n"
	result += "        done <= 1'b0;\n"
	result += "        clr <= 1'b0;                   \n"
	result += "      end//write\n"
	result += "      stop_con:begin\n"
	result += "        shift <= 1'b1;\n"
	result += "        ss <= 1'b0;\n"
	result += "        clr <= 1'b0;\n"
	result += "        rdata <= rreg;\n"
	result += "        done <= 1'b1;\n"
	result += "      end\n"
	result += "      finish:begin\n"
	result += "        shift <= 1'b0;\n"
	result += "        ss <= 1'b1;\n"
	result += "        done <= 1'b0;\n"
	result += "        clr <= 1'b1;\n"
	result += "      end\n"
	result += "      default: begin\n"
	result += "         shift <= 1'b0;\n"
	result += "         ss <= 1'b1;\n"
	result += "         done <= 1'b0;\n"
	result += "         clr <= 1'b0;\n"
	result += "      end\n"
	result += "    endcase\n"
	result += "  end//always\n"
	result += "\n"
	result += "  //setup falling edge (shift dout) sample rising edge (read din)\n"
	result += "  always@(negedge clk or posedge clr) \n"
	result += "  begin\n"
	result += "    if(clr) begin \n"
	result += "      cnt<=0; \n"
	result += "      sck<=0; \n"
	result += "    end\n"
	result += "    else begin\n"
	result += "      if(shift) begin\n"
	result += "		    cnt<=cnt+1; \n"
	result += "	      if(cnt==mid) begin\n"
	result += "	  	    sck<=~sck;\n"
	result += "		      cnt<=0;\n"
	result += "		    end //mid\n"
	result += "	   end //shift\n"
	result += "    end //rst\n"
	result += "  end //always\n"
	result += "\n"
	result += "\n"
	result += "  always@(posedge sck or posedge clr ) \n"
	result += "  begin \n"
	result += "      if(clr==1)  \n"
	result += "      begin\n"
	result += "          nbit <= 'b0;  \n"
	result += "          rreg <= 'b0;  \n"
	result += "      end\n"
	result += "      else \n"
	result += "      begin\n"
	result += "        if(cur==read) begin \n"
	result += "          rreg <= {rreg[ETHERNET_LENGTH-2:0],din};\n"
	result += "        end\n"
	result += "        nbit <= nbit + 1'b1;\n"
	result += "      end //rst\n"
	result += "  end //always\n"
	result += "\n"
	result += "  wire [ETHERNET_LENGTH-1-8:0] zero = 'b0;\n"
	result += "  wire [ETHERNET_LENGTH-1+8:0] treg_i = (cmd[7:5]==WBM) ? {cmd, wdata} : {zero, cmd, tdat};\n"
	result += "  \n"
	result += "  always@(negedge sck or posedge start) \n"
	result += "  begin\n"
	result += "    if(start) \n"
	result += "      treg <= treg_i; \n"
	result += "    else\n"
	result += "		  treg <= {treg[ETHERNET_LENGTH+8-2:0],1'b1}; \n"
	result += "  end //always\n"
	result += "\n"
	result += "  assign dout = (cmd[7:5]==WBM) ? treg[ETHERNET_LENGTH+8-1] : treg[15]; \n"
	result += "\n"
	result += "endmodule\n"
	return result
}

func (sl *Etherbond_extra) ExtraFiles() ([]string, []string) {
	return []string{}, []string{}
}

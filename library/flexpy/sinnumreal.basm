;fragtester range numberreal arange(-5,5,0.1)
;fragtester instance sinprec 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20
;sympy from sympy import *
;sympy x = Symbol('x', real=True)
;sympy symbols = [x]
;sympy testRanges = {'real: x': list(np.arange(-5,5,0.1)),
;sympy     'imag: x': list(np.arange(-5,5,2)),
;sympy     'real: y': list(np.arange(-5,5,2)),
;sympy     'imag: y': list(np.arange(-5,5,2)),
;sympy     }
;sympy with evaluate(False):
;sympy     spExpr = sin({{ .Params.numberreal }})  
;
;
; sine of real immediate value
; {{ .Params.numberreal }} is the real immediate value
%fragment sinnumreal template:true default_sinprec:20 default_setop:rset default_prefix:0f resout:r1
	{{ .Params.setop }}	r0, {{ .Params.prefix }}{{ .Params.numberreal }} ; load the immediate value
	mov     r1, r0 ; r1 is the result, starts with x
        mov     r2, {{ .Params.prefix }}2.0 ; r2 is the index (starts at 2 for 3!)
        mov     r3, {{ .Params.prefix }}1.0 ; r3 is the denominator
        mov     r4, {{ .Params.prefix }}1.0 ; r4 is used for sign inversion and for +1 operation
        mov     r5, r0 ; r5 is the numerator, starts with x
        mov     r6, {{ .Params.sinprec }} ; r6 is the precision
	mov     r7, {{ .Params.prefix }}1.0 ; r7 is numerator / denominator
loop:
        mov     r4, {{ .Params.prefix }}-1.0 ; r4 is used for sign inversion and for +1 operation
	{{ .Params.multop }}	r3, r4 ; sign inversion (the sign will follow r3)
        mov     r4, {{ .Params.prefix }}1.0 ; r4 is used for sign inversion and for +1 operation

	{{ .Params.multop }}	r3, r2 ; denominator progression (factorial of r2)
	{{ .Params.multop }}	r5, r0 ; numerator progression (x^r2)
	{{ .Params.addop }}	r2, r4 ; r2 = r2 + 1
	; One factor is not added
	{{ .Params.multop }}	r3, r2 ; denominator progression (factorial of r2)
	{{ .Params.multop }}	r5, r0 ; numerator progression (x^r2)
	{{ .Params.addop }}	r2, r4 ; r2 = r2 + 1

	cpy	r7, r5 ; r7 = x^r2
	{{ .Params.divop }}	r7, r3 ; r7 = x^r2 / factorial(r2)
	
	{{ .Params.addop }}	r1, r7 ; r1 = r1 + x^r2 / factorial(r2)

	dec	r6 ; decrement precision
	jz	r6, exit ; if r6 == 0, exit
	j loop ; else, loop
exit:
	nop	
%endfragment
